\documentclass{report}


\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}

\usepackage{fancyhdr}
\usepackage{lettrine}
\usepackage{hyperref}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{cite}
\usepackage{listings}
\usepackage[nottoc, numbib]{tocbibind}
\usepackage{../assets/scripts/tex/color-env}
\usepackage[ngerman]{babel}
\usepackage[Glenn]{fncychap}
\usepackage{trfsigns}
\input{../assets/scripts/tex/structure.tex}


\usetikzlibrary{shapes}
    \usetikzlibrary{arrows}
    \usetikzlibrary{arrows.meta,topaths}
    \usetikzlibrary{bending}
    \usetikzlibrary{calc}
\title{Elektrotechnik 1 Praktikum 1}


\usepackage[
  includehead,
  headheight = 17mm,
  footskip = \dimexpr\headsep+\ht\strutbox\relax,
  tmargin = 0mm,
  bmargin = \dimexpr17mm+2\ht\strutbox\relax,
]{geometry}

\usepackage{anyfontsize}

\usepackage{xcolor}

\definecolor{DarkGreenBlue}{HTML}{264653}
\definecolor{LightGreenBlue}{HTML}{2A9D8F}
\definecolor{LightOrange}{HTML}{E9C46A}
\definecolor{DarkOrange}{HTML}{F4A261}
\definecolor{RedOrange}{HTML}{E76F51}
\definecolor{BrightRed}{HTML}{D62828}
\definecolor{DeepBlue}{HTML}{003049}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{code}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=code}

\pagestyle{fancy}
\fancyhead[L]{\leftmark}
\fancyhead[R]{}
\fancyfoot[L]{}
\fancyfoot[C]{\thepage}
\fancyfoot[R]{\includegraphics[scale=0.2]{../assets/images/haw.jpg}}
\renewcommand\headrulewidth{0.5pt}


\begin{document}


\thispagestyle{empty}
\begin{tikzpicture}[overlay,remember picture]
  \thispagestyle{empty}
  \fill[black!2] (current page.south west) rectangle (current page.north east);

  \begin{scope}[transform canvas ={rotate around ={45:($(current page.north west)+(-.5,-6)$)}}]

    \shade[rounded corners=18pt, left color=DarkGreenBlue, right color=LightGreenBlue] ($(current page.north west)+(-.5,-6)$) rectangle ++(9,1.5);

  \end{scope}

  \begin{scope}[transform canvas ={rotate around ={45:($(current page.north west)+(.5,-10)$)}}]

    \shade[rounded corners=18pt, left color=LightOrange,right color=DarkOrange] ($(current page.north west)+(0.5,-10)$) rectangle ++(15,1.5);

  \end{scope}

  \begin{scope}[transform canvas ={rotate around ={45:($(current page.north west)+(0.5,-10)$)}}]

    \shade[rounded corners=8pt, right color=DarkOrange, left color=LightOrange] ($(current page.north west)+(1.5,-9.55)$) rectangle ++(7,.6);

  \end{scope}

  \begin{scope}[transform canvas ={rotate around ={45:($(current page.north)+(-1.5,-3)$)}}]

    \shade[rounded corners=12pt, left color=DeepBlue!80, right color=DeepBlue!60] ($(current page.north)+(-1.5,-3)$) rectangle ++(9,0.8);

  \end{scope}

  \begin{scope}[transform canvas ={rotate around ={45:($(current page.north)+(-3,-8)$)}}]

    \shade[rounded corners=28pt, left color=BrightRed, right color=BrightRed!80] ($(current page.north)+(-3,-8)$) rectangle ++(15,1.8);

  \end{scope}

  \begin{scope}[transform canvas ={rotate around ={45:($(current page.north west)+(4,-15.5)$)}}]

    \shade[rounded corners=25pt, left color=RedOrange, right color=DarkOrange] ($(current page.north west)+(4,-15.5)$) rectangle ++(30,1.8);

  \end{scope}

  \begin{scope}[transform canvas ={rotate around ={45:($(current page.north west)+(13,-10)$)}},]

    \shade[rounded corners=22pt, left color=DeepBlue,right color=DarkGreenBlue] ($(current page.north west)+(13,-10)$) rectangle ++(15,1.5);

  \end{scope}

  \begin{scope}[transform canvas ={rotate around ={45:($(current page.north west)+(18,-8)$)}},]

    \shade[rounded corners=8pt, left color=DarkOrange] ($(current page.north west)+(18,-8)$) rectangle ++(15,0.6);

  \end{scope}

  \begin{scope}[transform canvas ={rotate around ={45:($(current page.north west)+(19,-5.65)$)}},]

    \shade[rounded corners=12pt, left color=RedOrange] ($(current page.north west)+(19,-5.65)$) rectangle ++(15,0.8);

  \end{scope}

  \begin{scope}[transform canvas ={rotate around ={45:($(current page.north west)+(20,-9)$)}}]

    \shade[rounded corners=20pt, left color=BrightRed, right color=BrightRed!80] ($(current page.north west)+(20,-9)$) rectangle ++(14,1.2);

  \end{scope}

  \draw[ultra thick,gray] ($(current page.center)+(5,2)$) -- ++(0,-3cm) node[midway,left=0.25cm,text width=5cm,align=right,black!75]{{\fontsize{25}{30} \selectfont \bf MP\\[10pt] Praktikum 2}} node[midway,right=0.25cm,text width=6cm,align=left,orange]{{\fontsize{70}{86} \selectfont 2021}};

  \node at ($(current page.center)+(0,-4)$) {{\fontsize{40}{72} \selectfont Timer und Interrupts}};

  \node[text width=8cm,align=center] at ($(current page.center)+(0,-6.5)$) {{\fontsize{16}{20} \selectfont \textcolor{orange}{ \bf \today}} \\[3pt] Florian Tietjen 2519584\\[3pt] Emily Antosch 2519935};

\end{tikzpicture}

\newpage


\tableofcontents

\listoffigures

\lstlistoflistings

\newpage

\chapter{Die Temperatur-Regelstrecke}

\section{Einführung}

Im ersten Praktikum wollen wir uns mit dem Evaluation Board TM4C1294NCPDT vertraut machen,
mit dem wir uns auch in den nächsten Praktika beschäftigen wollen. Dabei richten wir
über den Projektbrowser und den Projekteigenschaften alle wichtigen Eigenschaften ein,
testen erste Konsolenausgaben und lassen LEDs in bestimmten Blinkmustern aufleuchten.


\section{Vorbereitung}

\subsection{V1.1}

Wir wollen uns zunächst über die Begriffe Kennlinienfeld, Arbeitspunkt und stationäres Verhalten klar werden:

\paragraph{Kennlinienfeld} Als Kennlinienfeld bezeichnen wir ein Feld, also eine Anreihung, von Kennlinien, also einem Zusammenhang zweier physikalischer Größen in graphischer Darstellung,
in einem einzigen Diagramm zur Veranschaulichung der Betriebsmitteleigenschaft unter verschiedenen Umständen

\paragraph{Arbeitspunkt} Der Arbeitspunkt beschreibt den Punkt im Kennlinienfeld, in dem ein technisches Gerät, aufgrund der äußeren Einflüsse und der gewählten Umstände arbeitet.

\paragraph{stationäres Verhalten} Als stationäres Verhalten beschreiben wir den Zustand, in dem eine Regelstrecke einen festen Zusammenhang zwischen Eingangs- und Ausgangsgröße erreicht hat. Der Endwert des Regelkreises wurde erreicht.


\vspace{1emy}
\noindent
Wir wollen nun den Zusammenhang der Kennlinienfelder im Vorfeld bestimmen und das Ergebnis in der Auswertung überprüfen. Aus

\begin{equation}
  \label{eq:1}
  \vartheta = \frac{1}{c_{L}\rho_{L}A}\frac{1}{v}P_{th}
\end{equation}

können wir erkennen, dass der Zusammenhang aus Heizspannung $u_{uP}$ und $u_{y\vartheta}$ linear sein muss. Da alle weiteren Werte in der Gleichung als konstant für unser Kennlinienfeld angenommen werden, bleibt nur noch eine Funktion der Form
\begin{equation}
  \label{eq:2}
  f(u_{uP}) = u_{y\vartheta} = m\cdot x
\end{equation}
übrig. Da die Spannung auch proportional zur Leistung $P_{el}$ ist, überträgt sich diese Proportionalität auf diesen Zusammenhang.

Der Zusammenhang zwischen Lüfterspannung $U_{uL}$ und $u_{y\vartheta}$ ergibt sich über eine ähnliche Argumentation als linear anti-proportional, da die Lüfterspannung in \ref{eq:1} direkt die Luftgeschwindigkeit beeinflusst. Es ergibt sich:
\begin{equation}
  \label{eq:3}
  f(u_{uL}) = u_{y\vartheta} = m\cdot \frac{1}{x}
\end{equation}

\subsection{V1.2}

Als nächstes wollen wir die Sprungantwort der Temperaturkurve auf einen Heizleisungssprung $P_{el}(t) = \hat{P}_{el}(t)\sigma(t)$ berechnen.
\begin{align}
  P_{el}(t) &\laplace P_{el}(s)\\
  P_{0}\cdot \sigma(t) &\laplace P_{0}\cdot \frac{1}{s}\\
\end{align}

Wir setzen nun diese Transformation in die Übertragungsfunktion des Grundlagenteils ein:

\begin{equation}
  \label{eq:4}
  \vartheta(s) = G_{s}(s)\cdot P_{el}(s) = K_{s}\frac{e^{-T_{t}s}}{1+T_{s}s}\cdot P_{el}
\end{equation}
\begin{equation}
  \label{eq:5}
  \vartheta(s) = K(s)\frac{e^{-T_{t}s}}{1+T_{t}s}\cdot P_{0} \cdot \frac{1}{s}
\end{equation}

Wir transformieren diesen Ausdruck nun wieder in den Zeitbereich über
\begin{equation}
  \label{eq:6}
  \vartheta(t) = K_{s} \cdot P_{0}\cdot \mathcal{L}^{-1}\left\{\frac{1}{s}\cdot e^{-T_{t}s}\cdot\frac{1}{1+T_{s}s}\right\} = K_{s} \cdot P_{0} \cdot \frac{1}{T_{s}} \cdot \mathcal{L}^{-1}\left\{\frac{1}{s}\cdot e^{-T_{t}s}\cdot \frac{1}{\frac{1}{T_{s}}+s}\right\}
\end{equation}
Mithilfe des Verschiebungs- und Integrationssatzes erhalten wir:

\begin{equation}
  \label{eq:7}
  \vartheta(t) = K_{s}\cdot P_{0}\cdot \frac{1}{T_{s}}\cdot \int_{0}^{t-T_{t}}e^{-\frac{-\tau}{T_{s}}}d\tau \cdot \sigma(t-T_{t})
\end{equation}

Wir bilden nun die Stammfunktion und vereinfachen so weit wie möglich:
\begin{equation}
  \label{eq:8}
  \vartheta(t) = K_{s}\cdot P_{0} \cdot \frac{1}{T_{s}} \left[-T_{s}\cdot e^{-\frac{t}{T_{s}}}\right]_{0}^{t-T_{t}}\sigma(t-T_{t}) = K_{s}\cdot P_{0} \cdot \frac{1}{T_{s} }
\end{equation}


\section{Aufgabe 1: Binärzähler mit Timer}

\subsection{Teilaufgabe A}

Für die zu bewältigende Aufgabe müssen die GPIO-Pins der Register N und F konfiguriert werden, da diese direkt mit den LEDs des Evaluation Boards verbunden sind.
Dazu verwenden wir folgenden Programmabschnitt, den wir schon aus Praktikum 1 kennen:
\begin{lstlisting}[language=c, caption={GPIO-Port Konfiguration}, captionpos=b]
void init() {
    // Setting the clock to both registers N and F
    SYSCTL_RCGCGPIO_R = 0x00001020;
    // Waiting for the clock to be ready
    while ((SYSCTL_PRGPIO_R & 0x00001020) == 0);
    // Setting the direction of the pins to output
    GPIO_PORTF_AHB_DIR_R = 0x11;
    GPIO_PORTN_DIR_R = 0x03;
    // Enabling all of the pins
    GPIO_PORTN_DEN_R = 0x03;
    GPIO_PORTF_AHB_DEN_R = 0x11;
}
\end{lstlisting}

\subsection{Teilaufgabe B}

Für das Einstellen der Load Value des Timers im 32-bit Modus wollen wir den Befehl
\begin{verbatim}
    TIMER0_TAILR_R = 0x00FFFFFF;
\end{verbatim}

Den einzustellenden Wert errechnen wir aus der Taktfrequenz f des Boards.

\begin{equation}
    lV = 1s \cdot f = 1s \cdot 16MHz = 16000000_{10}
\end{equation}
Aus den Vorlesungsfolien des Kapitels 5 zu dem 32-bit-Timer haben wir dann den Zahlenwert für die Timerperiode von einer Sekunde gefunden, welche dort mit $0\mathrm{x}00FFFFFF \approx 1,048s$ angegeben ist.

\subsection{Teilaufgabe C}

Mit einem 16-bit-Timer ohne Prescaler kann maximal ein Wert von $T = 65536$ erreicht werden. Dieser entspricht, bei einer Taktfrequenz von $16MHz$, einer Periodendauer von $t = 4,096 ms$. Aus $1s >> 4,096ms$ folgt, dass wir einen Prescaler für das Erreichen unseres Zieles brauchen. Daher rechnen wir:
\begin{equation}
    T_{p} = \frac{1s}{2^{16}} = 15,3\mu s \implies \frac{1}{15,3 \mu s} = 65,359kHz = f_p
\end{equation}

\subsection{Teilaufgabe D}

Wir wollen nun den direkten Wert für unseren Prescaler berechnen, daher rechnen wir:

\begin{equation}
    p = \frac{16MHz}{f_{p}} = 244,8 \approx 245
\end{equation}

Um nun die Load Value zu berechnen, nutzen wir eine Formel aus der Vorlesung und schreiben:

\begin{equation}
    \mathrm{ILR} = (\frac{16M}{245} \cdot 1) - 1 = 65306 - 1
\end{equation}

Wir schreiben also in unseren Code:

\begin{verbatim}
    TIMER0_TAPR_R = 245;
    TIMER0_ TAILR_R = 65306-1;
\end{verbatim}



\section{Programm: Binärzähler mit Timer}

%\begin{task}
%UIn der ersten Aufgabe wollen wir die Ausgabe in der Konsole des Code Composer Studios
%betrachten.
%\end{task}

Für das Bearbeiten dieser Aufgabe nutzen wir den folgenden Code:

\begin{lstlisting}[language=c, caption={timer.c}, captionpos=b]
/*
Mikroprozessortechnik 1 - Praktikum 2: Timer und Interrupts
Aufgabe 2
Autoren: Emily Antosch, Florian Tietjen
Beschreibung: Implementierung des Timers als Zeitmessung fuer die Darstellung von Binaerzahlen mithilfe von LEDs auf dem Evaluation Board.
*/

#include<stdint.h>
#include "inc\tm4c1294ncpdt.h"

void init();
void timerInit();

int main(void)
{
    // Call to the init function
    init();
    // Call to the timerInit function
    timerInit();
    // Initialization of the variables for the binary number
    unsigned short displayedValue = 0;
    // Infinite loop

    while(1)
    {
        // Calculating the binary number
        GPIO_PORTF_AHB_DATA_R = (displayedValue & 0x02) << 3 | (displayedValue & 0x01);
        GPIO_PORTN_DATA_R = (displayedValue & 0x0C) >> 2;
        // Incrementing the displayedValue
        displayedValue == 15 ? displayedValue = 0 : displayedValue++;
        //Waiting for the timer to reach timeout
        while ((TIMER0_RIS_R & (1<<0)) == 0);
        // Clearing the timer timeout flag
        TIMER0_ICR_R |= (1<<0);
    }
}
// Function to initialize the registers
void init(){
    // Setting the clock to both registers N and F
    SYSCTL_RCGCGPIO_R = 0x00001020;
    // Waiting for the clock to be ready
    while ((SYSCTL_PRGPIO_R & 0x00001020) == 0);
    // Setting the direction of the pins to output
    // and enabling the both registers with the pins
    GPIO_PORTF_AHB_DEN_R = 0x11;
    GPIO_PORTF_AHB_DIR_R = 0x11;
    GPIO_PORTN_DEN_R = 0x03;
    GPIO_PORTN_DIR_R = 0x03;

}
// Function to initialize the timer
void timerInit(){
    // Setting the clock to the timer
    SYSCTL_RCGCTIMER_R |= (1<<0);
    // Waiting for the clock to be ready
    while((SYSCTL_PRTIMER_R & 0x01) == 0);
    // Disabling the timer
    TIMER0_CTL_R &= ~(1<<0);
    // Setting the timer to be in 32-bit mode
    TIMER0_CFG_R = 0x00;
    // Setting the timer to be in periodic mode and match enable
    TIMER0_TAMR_R = 0x02 | (1<<3);
    // Setting the load value to be equal to about 1 second
    TIMER0_TAILR_R = 0x00FFFFFF;
    // Enabling the timer
    TIMER0_CTL_R |= (1<<0);
}

\end{lstlisting}

Dabei schließen wir das Evaluation Board an und führen das Programm dann im Debugmodus aus.
Auf der Konsole erscheint eine schnell wachsende Liste von dem eingegebnen Namen, der Matrikelnummer und der steigenden Zählervariable cnt. Das zeigt uns zum Einen, wie wir die
printf-Funktion in Code Composer Studio zu nutzen haben, um in größeren Programmen, Fehler finden zu können, zum Anderen haben wir das Setup des Boards richtig gemacht und das Kompilieren und Ausführen von Programmen funktioniert.


\newpage

\section{Programm: Interrupts und Interrupthandler}


%\begin{task}
%  UIn der zweiten Aufgabe wollen wir üben, mit der Hardware auf dem Board zu arbeiten und %bestimmte Register anzusprechen.
%\end{task}

Dazu verwenden wir den folgenden Code:

\begin{lstlisting}[language=c, caption={Timer-Interrupt mithilfe des Timers 2 im 32-bit-mode}, captionpos=b]
/*
Mikroprozessortechnik 1 - Praktikum 2: Timer und Interrupts
Aufgabe 2
Autoren: Emily Antosch, Florian Tietjen
Beschreibung: Implementierung eines Interrupts durch einen Timer auf der NVIC-Ebene. Darstellung eines Laufmusters mithilfe der LEDs.
*/

#include<stdio.h>
#include<stdint.h>
#include "inc\tm4c1294ncpdt.h"

// Function prototypes
void init();
void timerInit(unsigned long period);
void Timer2A_Handler();


// main function
int main(void){
    // Call init function
    init();
    // Call timerInit function
    timerInit(0x01EFFFFF);
    // Enable timer
    TIMER2_CTL_R |= 0x00000001;
    // Empty while loop
    while(1)
    {

    }
}
// Function to initialize the GPIO pins
void init(){
    SYSCTL_RCGCGPIO_R |= 0x00001020;
    while((SYSCTL_PRGPIO_R & 0x00001020)==0);
    // Initialization of ports by enabling and setting them to output
    GPIO_PORTF_AHB_DEN_R |= 0x11;
    GPIO_PORTF_AHB_DIR_R |= 0x11;
    GPIO_PORTN_DEN_R |= 0x03;
    GPIO_PORTN_DIR_R |= 0x03;
}
// Function to initialize the timer
void timerInit(unsigned long period){
    // Set clock to timer 2
    SYSCTL_RCGCTIMER_R |= 0x04;
    // Wait for clock to be set up
    while((SYSCTL_PRTIMER_R&0x04)==0);
    //Disable timer 2
    TIMER2_CTL_R &= ~0x01;
    //Set timer to 32-bit mode
    TIMER2_CFG_R = 0x00;
    // Enable periodic mode
    TIMER2_TAMR_R = 0x02;
    // Set load value to parameter period - 1
    TIMER2_TAILR_R = period-1;
    // Clear timeout flag
    TIMER2_ICR_R = 0x01;
    // Enable timer to start an interrupt on timeout flag
    TIMER2_IMR_R = 0x01;
    // Enable NVIC to timer 2 to send an interrupt to CPU
    NVIC_EN0_R |= (1<<23);
}

// Function to handle the interrupt
void Timer2A_Handler(){
    // Create i for delay
    int i = 0;
    // Clear timeout flag
    TIMER2_ICR_R |= 0x01;
    // Set LED pattern to light up all LEDs
    GPIO_PORTN_DATA_R = 0x03;
    GPIO_PORTF_AHB_DATA_R = 0x11;
    for(i = 0; i < 600000; i++)
        ;
    // Clear LEDs to wait for next interrupt
    GPIO_PORTN_DATA_R = 0x00;
    GPIO_PORTF_AHB_DATA_R = 0x00;
}


\end{lstlisting}

Dabei verwenden wir die beiden Register F und N, in welchen die Pins für die LEDs auf dem Board sind. Wir setzen alle Pins auf Ausgang und Enablen diese. Im Nachgang setzen wir die jeweiligen Pins im entsprechenden Blinkmuster auf OFF oder ON mit einer Warteschleife dazwischen.

\subsection{Ausgabe des Programms}

Wir erkennen einen durchgängigen Verlauf der LEDs, bei dem die LEDs der Reihe nach aufleuchten und dann wieder ausgehen, sodass immer nur eine
LED zur Zeit eingeschaltet ist. Es entsteht der Effekt eines "laufenden" Lichts, welches sich immer von links nach rechts bewegt.

\newpage

\subsection{Gleichzeitige Schaltung beider Eingänge in Port N}

Um beide LEDs an Port N gleichzeitig zu schalten müssen wir lediglich folgende Programmzeilen verwenden:
\begin{lstlisting}[language=c, caption={Port N Pins gleichzeitig schalten}, captionpos=b]
  GPIO_PORTN_DATA_R = 0x03;
  GPIO_PORTN_DATA_R = 0x00;
\end{lstlisting}
Dabei ist die erste Zeile das Schalten beider Pins auf ON, die zweite Zeile schaltet beide auf OFF. Dabei gilt $0x03_{16} = 0011_2$ und $0x00_{16} = 0000_2$, wobei eine $1$ auf einem bestimmten Port ein ON-Signal und eine $0$ ein OFF-Signal darstellt.

\end{document}
